#menu
menuFile.text = File
menuEdit.text = Edit
menuHelp.text = Help
menuInfoAlgorithm.text = Algorithm Description
menuAbout.text = Info
menuExit.text = Exit
menuNewSim.text = New simulation
menuExportGraph.text = Esport grafico
menuImportGraph.text = Import simulation
menuExportSim.text = Esport simulazion

#help handler
helpTitle.text = Scheduler Info

#exit handler
exitTitle.text = Confirmation
exitHeader.text = EXIT THE APPLICATION
exitContent.text = Are you sure you want to quit?

#CreateDialog
textInputDialog.text = Enter the name of the simulation
textAlgori.text = Select the algorithm to execute
creaSimulation.text = Create simulation
annullaCreaSimulation.text = Cancel

#ExitDialog
exitDialogTitle.text = Closing process
exitDialogSure.text = Are you sure you want to close the process?
exitDialogClose.text = Close
exitDialogCancel.text = Cancel

#Edit dialog
editDialogTitle.text = Edit process
editDialogConfirm.text = Confirm
editDialogAnnulla.text = Cancel

closeDescription.text = Close
selezioneDescrizione.text = Select the algorithm to learn about
showDescription.text = Show description

#TODO FIXARE GLI ACCENTI CHE NON LI LEGGE JESUS
FIFO.text = First in, first out (FIFO), also known as first come, first served (FCFS), is the simplest scheduling algorithm. FIFO simply queues processes in the order that they arrive in the ready queue. This is commonly used for a task queue, for example as illustrated in this section.
SJF.text =Shortest job next (SJN), also known as shortest job first (SJF) or shortest process next (SPN), is a scheduling policy that selects for execution the waiting process with the smallest execution time.[1] SJN is a non-preemptive algorithm. Shortest remaining time is a preemptive variant of SJN. Shortest job next is advantageous because of its simplicity and because it minimizes the average amount of time each process has to wait until its execution is complete. However, it has the potential for process starvation for processes which will require a long time to complete if short processes are continually added. Highest response ratio next is similar but provides a solution to this problem using a technique called aging.
ROUND.text = Round-robin (RR) is one of the algorithms employed by process and network schedulers in computing.[1][2] As the term is generally used, time slices (also known as time quanta)[3] are assigned to each process in equal portions and in circular order, handling all processes without priority (also known as cyclic executive). Round-robin scheduling is simple, easy to implement, and starvation-free. Round-robin scheduling can be applied to other scheduling problems, such as data packet scheduling in computer networks. It is an operating system concept.
LOTTERY.text = Lottery scheduling is a probabilistic scheduling algorithm for processes in an operating system. Processes are each assigned some number of lottery tickets, and the scheduler draws a random ticket to select the next process. The distribution of tickets need not be uniform; granting a process more tickets provides it a relative higher chance of selection. This technique can be used to approximate other scheduling algorithms, such as Shortest job next and Fair-share scheduling.
RMA.text = In computer science, rate-monotonic scheduling (RMS)[1] is a priority assignment algorithm used in real-time operating systems (RTOS) with a static-priority scheduling class.[2] The static priorities are assigned according to the cycle duration of the job, so a shorter cycle duration results in a higher job priority. These operating systems are generally preemptive and have deterministic guarantees with regard to response times. Rate monotonic analysis is used in conjunction with those systems to provide scheduling guarantees for a particular application.
EDF.text = Earliest deadline first (EDF) or least time to go is a dynamic priority scheduling algorithm used in real-time operating systems to place processes in a priority queue. Whenever a scheduling event occurs (task finishes, new task released, etc.) the queue will be searched for the process closest to its deadline. This process is the next to be scheduled for execution. EDF is an optimal scheduling algorithm on preemptive uniprocessors, in the following sense: if a collection of independent jobs, each characterized by an arrival time, an execution requirement and a deadline, can be scheduled (by any algorithm) in a way that ensures all the jobs complete by their deadline, the EDF will schedule this collection of jobs so they all complete by their deadline.